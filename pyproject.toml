[tool.poetry]
name = "cache_simulator"
version = "0.0.0"
description = "A simulator for processor caches"
authors = ["Pavel Kravchenya <kpdphys@example.com>"]
license = "MIT"
readme = "README.md"
package-mode = false

# Core runtime dependencies
[tool.poetry.dependencies]
python = ">=3.13,<4.0"
numpy = ">=2.2.6,<3.0.0"         # Fundamental package for array computing
torch = ">=2.7.0,<3.0.0"         # Tensors and Dynamic neural networks
PyYAML = ">=6.0.2,<7.0.0"        # YAML parser and emitter
dvc = ">=3.59.2,<4.0.0"          # Tool to manage code and data together
python-dotenv = ">=1.1.0,<2.0.0" # Set key-value pairs from a .env file
deepspeed = ">=0.16.8,<1.0.0"    # DeepSpeed library
mlflow = ">=2.22.0,<3.0.0"       # A platform for the complete ML lifecycle
dagshub = ">=0.5.10,<1.0.0"      # DagsHub client libraries
optax = ">=0.2.0,<1.0.0"

# Optional group of dependencies for special requirements (mpi, cuda, etc.)
[tool.poetry.group.special]
optional = true

[tool.poetry.group.special.dependencies]
causal-conv1d = ">=1.5.0,<2.0.0" # Causal depthwise conv1d in CUDA
mamba-ssm = ">=2.2.4,<3.0.0"     # Mamba state-space model
mpi4py = ">=4.0.3,<5.0.0"        # Python bindings for MPI

# Optional group of development dependencies
[tool.poetry.group.dev]
optional = true

[tool.poetry.group.dev.dependencies]
ruff = ">=0.11.10,<1.0.0"                    # Python linter and code formatter
mypy = ">=1.15.0,<2.0.0"                     # Optional static typing for Python
pytest = ">=8.3.5,<9.0.0"                    # A powerful testing framework
pytest-mock = ">=3.14.0,<4.0.0"              # Mocking for pytest
coverage = ">=7.8.1,<8.0.0"                  # Code coverage measurement tool
pytest-cov = ">=6.1.1,<7.0.0"                # Pytest plugin for coverage.py integration
bandit = ">=1.8.3,<2.0.0"                    # Security oriented static analyser
pre-commit = ">=4.2.0,<5.0.0"                # Pre-commit hook management
detect-secrets = ">=1.5.0,<2.0.0"            # Tool for detecting secrets in the codebase
python-semantic-release = ">=9.21.1,<10.0.0" # Automatic Semantic Versioning

[build-system]
requires = ["poetry-core>=2.0.0,<3.0.0"]
build-backend = "poetry.core.masonry.api"

[tool.pytest.ini_options]
# Minimum required version of pytest
minversion = "8.0"

# Additional command-line options:
# -rA : show extra test summary info for all outcomes (failing, skipped, etc.)
# -q  : quiet mode (less verbose output)
# -v  : verbose mode (increases verbosity, shows detailed test names and outcomes)
addopts = "-ra -q -v"

[tool.semantic_release]
# Automatically update the version in pyproject.toml at the specified location
version_toml = ["pyproject.toml:tool.poetry.version"]

# The commit message used when creating a release commit
commit_message = "chore(release): version {version}\n\nAutomatically generated by python-semantic-release"

# Format used to create git tags for new releases
tag_format = "v{version}"

# The branch where releases should be made
branch = "main"

# The command that builds your project before publishing (optional).
build_command = "poetry build"

# Disable uploading to PyPI. Set to true if you want to publish the package.
upload_to_pypi = false

[tool.semantic_release.changelog]
#  The mode to use when updating the changelog file (init or update).
mode = "update"

# The insertion flag used to determine where to insert new changes in the changelog
insertion_flag = "<!-- version list -->"

# The directory where Jinja2 templates for the changelog are stored
template_dir = "templates"

[tool.semantic_release.changelog.default_templates]
# The default changelog file to use if none is specified
changelog_file = "CHANGELOG.md"

[tool.semantic_release.commit_parser_options]
#  List of tags that will result in a minor release
minor_tags = ["feat"]

# List of tags that will result in a patch release
patch_tags = ["fix", "perf"]

# List of tags that will be allowed, but will not trigger a release
other_allowed_tags = [
    "build",
    "chore",
    "ci",
    "docs",
    "style",
    "refactor",
    "test",
]

# List of all allowed tags for commit messages
allowed_tags = [
    "feat",
    "fix",
    "perf",
    "build",
    "chore",
    "ci",
    "docs",
    "style",
    "refactor",
    "test",
]

[tool.semantic_release.publish]
# Glob patterns to match the distribution files to upload
dist_glob_patterns = ["dist/*"]

# Whether to create a release on the VCS provider (e.g., GitHub Release).
upload_to_vcs_release = false

[tool.mypy]
# Target Python version for type checking
python_version = "3.13"

# Specify which files to check. This ensures that mypy
# only checks .py and .pyi files at any depth in the project
files = "**/*.py,**/*.pyi"

# Specify folder with stubs
mypy_path = "typings"

# Enable all strict checks
strict = true

# Ignore imports that can't be resolved
ignore_missing_imports = true

# Disallow functions without type annotations
disallow_untyped_defs = true

# Disallow use of untyped imported values
# disallow_any_unimported = true

# Warn when returning a value of type `Any`
warn_return_any = true

# Warn if `# type: ignore` comments are unused
warn_unused_ignores = false

# Resolve module name conflicts when same directory names exist in different packages
explicit_package_bases = true


# Ignore warnings about random unsecurity
[tool.bandit]
skips = ["B311"]


[tool.bandit.assert_used]
# Skip assert checks (B101) in test files,
# where usage of "assert" is expected and acceptable
skips = ["*/test_*.py", "*/*_test.py", "tests/*", "*/tests/*"]


[tool.ruff]
# Set length of code strings
line-length = 99

src = ["cache_simulator"]
include = ["pyproject.toml", "cache_simulator/**/*.py"]

# Specify file types to check
extend-include = ["*.py", "*.pyi"]

[tool.ruff.lint]
# Enable specific rules
select = [
    "F",  # Flake8 rules (unused imports, etc.)
    "D",  # Pydocstyle rules (documentation)
    "PT", # Pytest style
    "I",  # Import sorting (isort)
    "E",  # Code style (pycodestyle errors)
    "W",  # Style warnings (pycodestyle warnings)
    "B",  # Bug detection (flake8-bugbear)
]

# Ignore specific rules if needed
ignore = [
    "D203", # one-blank-line-before-class (conflicts with formatter)
    "D211", # no-blank-line-before-class
    "D213", # multi-line-summary-second-line
]

[tool.ruff.lint.isort]
known-first-party = ["cache_simulator"]
force-sort-within-sections = true

[tool.coverage.run]
# Measure branch coverage in addition to statement coverage
branch = true

# Disable .coverage file
data_file = "/tmp/coverage_data"

# Omit test files and virtual environments from coverage measurement
omit = ["*/tests/*", "*/test_*.py", "*/*_test.py", "*/venv/*", "*/.venv/*"]

[tool.coverage.report]
# Fail if total coverage percentage is below 80%
fail_under = 80

# Regexes for lines to exclude from consideration
exclude_also = [
    # Don't complain about missing debug-only code:
    "def __repr__",
    "if self\\.debug",

    # Don't complain if tests don't hit defensive assertion code:
    "raise AssertionError",
    "raise NotImplementedError",

    # Don't complain if non-runnable code isn't run:
    "if 0:",
    "if __name__ == .__main__.:",

    # Don't complain about abstract methods, they aren't run:
    "@(abc\\.)?abstractmethod",
]
